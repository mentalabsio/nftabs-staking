import { web3, utils } from "@project-serum/anchor";

import { Lock } from "./gen/accounts";
import { fromTxError } from "./gen/errors";
import { PROGRAM_ID } from "./gen/programId";

type ProgramAccounts = {
  pubkey: web3.PublicKey;
  account: web3.AccountInfo<Buffer>;
};

type LockAccount = Lock & { address: web3.PublicKey };

export const findFarmLocks = async (
  connection: web3.Connection,
  farm: web3.PublicKey
): Promise<LockAccount[]> => {
  const dataSize = 8 + Lock.layout.span;
  const filters = [
    { dataSize },
    accountFilter(Lock.discriminator),
    memcmp(8, farm.toBase58()),
  ];

  const accounts = await fetchAccounts(connection, filters);

  return Promise.all(
    accounts.map(async ({ pubkey, account }) => {
      return Object.assign(Lock.decode(account.data), { address: pubkey });
    })
  );
};

// Helper function to handle the errors generated by the program.
export function withParsedError<T, U>(
  fn: (...args: T[]) => Promise<U>
): (...args: T[]) => Promise<U> {
  return async function (...args: T[]) {
    try {
      return await fn(...args);
    } catch (e) {
      console.log(e.logs?.join("\n"));

      const parsed = fromTxError(e);

      if (parsed != null) {
        throw new Error(parsed.msg);
      }

      const err: string = e.logs
        ?.filter((l: string) => l.includes("Error"))
        .join("\n");

      throw new Error(err?.length > 0 ? err : e);
    }
  };
}

const memcmp = (offset: number, bytes: string): web3.MemcmpFilter => {
  return {
    memcmp: {
      offset,
      bytes,
    },
  };
};

const accountFilter = (discriminator: Buffer) => {
  return memcmp(0, utils.bytes.bs58.encode(discriminator));
};

const fetchAccounts = (
  connection: web3.Connection,
  filters: web3.GetProgramAccountsFilter[]
): Promise<ProgramAccounts[]> => {
  return connection.getProgramAccounts(PROGRAM_ID, {
    encoding: "base64",
    filters,
  });
};
