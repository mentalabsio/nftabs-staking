import {
  Metadata,
  MetadataProgram,
} from "@metaplex-foundation/mpl-token-metadata";
import { web3, utils } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";

import { Lock, StakeReceipt } from "./gen/accounts";
import { fromTxError } from "./gen/errors";
import { PROGRAM_ID } from "./gen/programId";
import { findFarmerAddress } from "./pda";

type ProgramAccounts = {
  pubkey: web3.PublicKey;
  account: web3.AccountInfo<Buffer>;
};

type LockAccount = Lock & { address: web3.PublicKey };

export const findFarmLocks = async (
  connection: web3.Connection,
  farm: web3.PublicKey
): Promise<LockAccount[]> => {
  const dataSize = 8 + Lock.layout.span;
  const filters = [
    { dataSize },
    accountFilter(Lock.discriminator),
    memcmp(8, farm.toBase58()),
  ];

  const accounts = await fetchAccounts(connection, filters);

  return Promise.all(
    accounts.map(async ({ pubkey, account }) => {
      return Object.assign(Lock.decode(account.data), { address: pubkey });
    })
  );
};

export const findUserStakeReceipts = async (
  connection: web3.Connection,
  farm: web3.PublicKey,
  userPublicKey: web3.PublicKey
): Promise<StakeReceipt[]> => {
  const farmer = findFarmerAddress({ farm, owner: userPublicKey });

  const filters = [
    accountFilter(StakeReceipt.discriminator),
    memcmp(8, farmer.toString()),
  ];

  const accounts = await fetchAccounts(connection, filters);

  return Promise.all(
    accounts.map(async (account) => {
      return StakeReceipt.decode(account.account.data);
    })
  );
};

export type FoundCreator = {
  metadataAddress: web3.PublicKey;
  creatorAddress: web3.PublicKey;
};

export const tryFindCreator = async (
  connection: web3.Connection,
  mint: web3.PublicKey
): Promise<FoundCreator | null> => {
  try {
    const metadataAddress = (
      await PublicKey.findProgramAddress(
        [
          Buffer.from("metadata"),
          MetadataProgram.PUBKEY.toBuffer(),
          mint.toBuffer(),
        ],
        MetadataProgram.PUBKEY
      )
    )[0];

    // Try to find metadata account.
    const metadataAccount = await Metadata.findByMint(connection, mint);

    // If we do, then we're trying to stake an NFT.
    const creatorAddress = new web3.PublicKey(
      metadataAccount.data.data.creators.find((c) => c.verified).address
    );

    return { creatorAddress, metadataAddress };
  } catch (e) {
    return;
  }
};

// Helper function to handle the errors generated by the program.
export function withParsedError<T, U>(
  fn: (...args: T[]) => Promise<U>
): (...args: T[]) => Promise<U> {
  return async function (...args: T[]) {
    try {
      return await fn(...args);
    } catch (e) {
      const parsed = fromTxError(e);

      if (parsed != null) {
        throw parsed;
      }

      throw e;
    }
  };
}

const memcmp = (offset: number, bytes: string): web3.MemcmpFilter => {
  return {
    memcmp: {
      offset,
      bytes,
    },
  };
};

const accountFilter = (discriminator: Buffer) => {
  return memcmp(0, utils.bytes.bs58.encode(discriminator));
};

const fetchAccounts = (
  connection: web3.Connection,
  filters: web3.GetProgramAccountsFilter[]
): Promise<ProgramAccounts[]> => {
  return connection.getProgramAccounts(PROGRAM_ID, {
    encoding: "base64",
    filters,
  });
};
